---
title: Plugin-Entwicklungsleitfaden
description: 'Vollständiger Leitfaden zur Entwicklung benutzerdefinierter Plugins für Open Ticket AI inklusive Projektstruktur, Entry Points und bewährten Verfahren.'
---

# Plugin-Entwicklungsleitfaden

Erfahren Sie, wie Sie benutzerdefinierte Plugins erstellen, um die Funktionalität von Open Ticket AI zu erweitern.

## Verpackungs- und Namensanforderungen

Open Ticket AI entdeckt Plugins anhand ihres Python-Paketnamens und der Projektmetadaten.

- **Distribution/project name**: muss mit `otai-` beginnen. Dies entspricht dem
  `AppConfig.PLUGIN_NAME_PREFIX` (`otai-`), das die Runtime beim Berechnen von Registry‑Keys verwendet.
- **Python package name**: Verwenden Sie dieselben Wörter wie beim Distributionsnamen, jedoch mit Unterstrichen
  (`otai_my_plugin`). Der Loader konvertiert den Top‑Level‑Modulnamen automatisch in kebab‑case, sodass
  `otai_my_plugin` intern zu `otai-my-plugin` wird.
- **Registry prefix**: Wenn ein Plugin Injectables registriert, wird das globale Präfix (`otai-`) entfernt und
  der Rest behalten (z. B. `otai-my-plugin` → `my-plugin`). Dieser Teil wird zum Registry‑Key‑Präfix,
  wenn er mit dem Namen des Injectables kombiniert wird, etwa `my-plugin:MyPipe`.

## Empfohlenes Projektlayout

```
otai-my-plugin/
├── pyproject.toml
├── src/
│   └── otai_my_plugin/
│       ├── __init__.py
│       ├── pipes/
│       │   └── my_pipe.py
│       ├── services/
│       │   └── my_service.py
│       └── plugin_factory.py
└── tests/
    └── unit/
        └── test_my_plugin.py
```

## Entry‑Point‑Vertrag

Open Ticket AI lädt Plugins über die `open_ticket_ai.plugins` Entry‑Point‑Gruppe. Der Entry‑Point
muss zu einem Callable auflösen, das eine `AppConfig`‑Instanz akzeptiert und ein `Plugin` zurückgibt.
Das Subclassing von `Plugin` erfüllt diesen Vertrag bereits, daher sollten Sie Ihr Subclass direkt exportieren.

```toml
[project.entry-points."open_ticket_ai.plugins"]
my_plugin = "otai_my_plugin.plugin_factory:PluginFactory"
```

### Warum die Klasse referenzieren?

- Der Loader ruft das Ziel wie eine Factory auf. Die Referenzierung des Subclass hält die Verkabelung
  deklarativ — keine Wrapper‑Funktion erforderlich.
- Der Klassenname verdeutlicht, dass die Instanziierung des Plugins möglicherweise Dependency‑Wiring erfordert
  (z. B. können Konstruktor‑Parameter über `AppConfig` hinaus vom IoC‑Container injiziert werden).

## Implementierung der PluginFactory‑Klasse

Alle Plugins erben von `open_ticket_ai.core.plugins.plugin.Plugin`. Die Basisklasse:

1. Akzeptiert `AppConfig` (vom Loader injiziert) im Konstruktor.
2. Nutzt den Top‑Level‑Modulnamen, um den Plugin‑Namen und das Registry‑Präfix abzuleiten.
3. Ruft `_get_all_injectables()` während `on_load` auf und registriert jedes `Injectable` automatisch
   beim `ComponentRegistry` nach dem Muster `<plugin-prefix>:<injectable-registry-name>`.

Der Separator zwischen Präfix und Injectable‑Name ist
`AppConfig.REGISTRY_IDENTIFIER_SEPERATOR`, standardmäßig `:`.

Überschreiben Sie `_get_all_injectables()`, um alle Injectables zurückzugeben, die Sie exportieren möchten. Sie sollten **nicht**
`registry.register(...)` selbst innerhalb von `on_load` aufrufen; die Basisklasse erledigt das für Sie.

```python
# src/otai_my_plugin/plugin_factory.py

from open_ticket_ai.core.injectables.injectable import Injectable
from open_ticket_ai.core.plugins.plugin import Plugin

from otai_my_plugin.pipes.my_pipe import MyPipe
from otai_my_plugin.services.my_service import MyService


class PluginFactory(Plugin):
    """Create the plugin instance and declare exported injectables."""

    def _get_all_injectables(self) -> list[type[Injectable]]:
        return [
            MyPipe,
            MyService,
        ]
```

Wenn der Loader `PluginFactory` instanziiert, wird die Basisimplementierung:

1. Das Registry‑Präfix (`my-plugin` in diesem Beispiel) berechnen.
2. `MyPipe.get_registry_name()` und `MyService.get_registry_name()` aufrufen.
3. Jedes Injectable als `my-plugin:<registry-name>` beim gemeinsamen `ComponentRegistry` registrieren.

### Rückgabe von Injectables vs. manuelle Registrierung

Frühere Implementierungen erforderten einen `setup(registry)`‑Helper, der die manuelle Registrierung vornahm. Mit
dem oben dargestellten Factory‑Muster geben Sie einfach die Liste der Injectables zurück und lassen die Basisklasse den Rest erledigen. Das sorgt für konsistente Registrierung und stellt sicher, dass Registry‑Namen automatisch dem
`prefix:Injectable`‑Konvention folgen.

Falls Sie das automatische Verhalten ausschalten müssen — z. B. um zusätzliche Aliase zu registrieren — können Sie
weiterhin innerhalb von `_get_all_injectables()` auf das Registry zugreifen, indem Sie `on_load` überschreiben. Für typische Anwendungsfälle ist das Zurückgeben der Liste ausreichend und bevorzugt.

## pyproject.toml Essentials

Stellen Sie sicher, dass die Metadaten mit den Namensregeln und dem Entry‑Point‑Vertrag übereinstimmen:

```toml
[project]
name = "otai-my-plugin"
version = "0.1.0"
description = "Custom plugin for Open Ticket AI"
requires-python = ">=3.13"
dependencies = [
    "open-ticket-ai>=1.0.0,<2.0.0",
]

[project.entry-points."open_ticket_ai.plugins"]
my_plugin = "otai_my_plugin.plugin_factory:PluginFactory"
```

Verwenden Sie den Distributionsnamen (`otai-my-plugin`), um sowohl das Modul‑Präfix (`otai_my_plugin`) als auch das Registry‑Präfix (`my-plugin`) abzuleiten. Die Konsistenz stellt sicher, dass der Loader Entry‑Points korrekt auflöst und vorhersehbare Registry‑Keys erzeugt.

## Verpacken, Verteilung & Testen

```
uv build
uv publish
```

Installieren Sie Ihr Plugin in einer Open Ticket AI‑Umgebung mit:

```
uv pip install otai-my-plugin
```

Schreiben Sie Unit‑Tests neben Ihrem Plugin‑Code unter `tests/unit/` und führen Sie sie aus mit
`uv run -m pytest`.

## Kommerzielle Plugins & Monetarisierung

Open Ticket AI unterstützt **commercial plugin development** vollständig mit uneingeschränkter Lizenzfreiheit. Sie können Plugins erstellen und verkaufen, ohne Einschränkungen durch das Kernprojekt.

### Entwicklerfreiheit

- **Choose your license**: MIT, GPL, proprietary — your choice
- **Set your pricing**: Free, paid, subscription, one-time — you decide
- **Support model**: Community support, commercial support, or both
- **No revenue sharing**: Keep 100 % of your plugin sales
- **No marketplace fees**: Currently no official marketplace (coming soon)

### Aktueller Stand & Zukunftspläne

- **Plugin Listings**: Available on the documentation site
- **No Marketplace Yet**: There is currently no official plugin marketplace or store
- **Future Plans**: A dedicated plugins showcase page is planned with search, categories, and
  community ratings

### Monetarisierungsstrategien

#### Strategie 1: Private PyPI + Lizenzschlüssel

Host your commercial plugin on a private PyPI server (DevPI, Gemfury, AWS CodeArtifact) that
customers access with authentication tokens. Implement license validation in your plugin's
initialization:

```python
import os
from open_ticket_ai.core.plugins.plugin import Plugin
from open_ticket_ai.core.injectables.injectable import Injectable


class LicenseError(Exception):
    """Raised when license validation fails."""
    pass


class MyCommercialPlugin(Plugin):
    """Commercial plugin with license validation."""

    def __init__(self, config):
        # Validate license before plugin initialization
        license_key = os.getenv('MY_PLUGIN_LICENSE_KEY')
        if not license_key or not self._validate_license(license_key):
            raise LicenseError(
                "Valid license key required. "
                "Visit https://myplugin.com for licensing."
            )
        super().__init__(config)

    def _validate_license(self, key: str) -> bool:
        """
        Implement your license validation logic.
        Examples:
        - API call to license server
        - Signature verification
        - Offline validation with cryptographic signatures
        """
        # Your validation logic here
        return self._verify_with_license_server(key)

    def _verify_with_license_server(self, key: str) -> bool:
        """Validate license key against remote server."""
        # Example implementation
        import requests
        try:
            response = requests.post(
                'https://api.myplugin.com/validate',
                json={'license_key': key},
                timeout=5
            )
            return response.status_code == 200 and response.json().get('valid')
        except Exception:
            # Consider grace period for network failures
            return False

    def _get_all_injectables(self) -> list[type[Injectable]]:
        return [MyService, MyPipe]
```

**Vorteile:**

- Full control over distribution
- Secure plugin delivery
- Customer-specific authentication
- Private code repository

**Nachteile:**

- Requires maintaining private PyPI infrastructure
- More complex installation for customers
- Less discoverable

#### Strategie 2: Public PyPI + Laufzeit‑Lizenzdurchsetzung

Publish your plugin to public PyPI for easy discovery, but implement runtime license validation.
Installation is free, but usage requires a valid license:

```python
import os
from open_ticket_ai.core.plugins.plugin import Plugin
from open_ticket_ai.core.injectables.injectable import Injectable


class LicenseError(Exception):
    """Raised when license validation fails."""
    pass


class PublicCommercialPlugin(Plugin):
    """Publicly available plugin with runtime license enforcement."""

    def _get_all_injectables(self) -> list[type[Injectable]]:
        """Validate license before exposing injectables."""
        license_key = os.getenv('MY_PLUGIN_LICENSE_KEY')

        if not license_key:
            raise LicenseError(
                "License key required to use this plugin.\n"
                "Set the MY_PLUGIN_LICENSE_KEY environment variable.\n"
                "Purchase a license at https://myplugin.com"
            )

        if not self._verify_license(license_key):
            raise LicenseError(
                "Invalid or expired license key.\n"
                "Visit https://myplugin.com to renew or purchase a license."
            )

        return [MyService, MyPipe]

    def _verify_license(self, key: str) -> bool:
        """Your license verification logic."""
        # Example: Check license format, expiration, signature
        return self._check_license_signature(key)

    def _check_license_signature(self, key: str) -> bool:
        """Verify license key signature (example)."""
        # Implement cryptographic signature verification
        # This allows offline validation
        return True  # Replace with actual verification
```

**Vorteile:**

- Easy installation via `uv add otai-my-plugin`
- Public discovery on PyPI
- Simple customer onboarding
- Trial versions possible (e.g., time‑limited grace period)

**Nachteile:**

- Plugin code is publicly visible
- Potential for license bypass attempts
- Requires robust license validation

#### Strategie 3: Freemium‑Modell

Offer a free tier with basic features and charge for premium functionality:

```python
import os
from open_ticket_ai.core.plugins.plugin import Plugin
from open_ticket_ai.core.injectables.injectable import Injectable


class FreemiumPlugin(Plugin):
    """Plugin with free and premium features."""

    def _get_all_injectables(self) -> list[type[Injectable]]:
        """Return free injectables always, premium only with license."""
        injectables = [
            # Always available
            BasicPipe,
            BasicService,
        ]

        # Add premium features if licensed
        license_key = os.getenv('MY_PLUGIN_LICENSE_KEY')
        if license_key and self._verify_license(license_key):
            injectables.extend([
                PremiumPipe,
                AdvancedService,
            ])

        return injectables

    def _verify_license(self, key: str) -> bool:
        """Verify premium license."""
        return True  # Your validation logic
```

### Best Practices zur Lizenzvalidierung

#### 1. Umgebungsvariablen

Use environment variables for license keys to keep them out of configuration files:

```python
license_key = os.getenv('MY_PLUGIN_LICENSE_KEY')
```

Users set it in their environment:

```bash
export MY_PLUGIN_LICENSE_KEY="your-license-key-here"
```

#### 2. Klare Fehlermeldungen

Provide actionable error messages that guide users to purchase licenses:

```python
if not license_key:
    raise LicenseError(
        "Missing license key for my-plugin.\n"
        "\n"
        "To use this commercial plugin:\n"
        "1. Purchase a license at https://myplugin.com\n"
        "2. Set the environment variable: MY_PLUGIN_LICENSE_KEY=<your-key>\n"
        "3. Restart Open Ticket AI\n"
        "\n"
        "For questions, contact support@myplugin.com"
    )
```

#### 3. Schnell scheitern

Validate licenses during plugin initialization, not at pipe execution time:

```python
# Good: Fails immediately on startup
class MyPlugin(Plugin):
    def __init__(self, config):
        self._validate_license()
        super().__init__(config)


# Bad: Fails when pipe is executed
class BadPipe(Pipe):
    def run(self, context):
        self._validate_license()  # Too late!
```

#### 4. Offline‑Unterstützung

Consider cached validation for intermittent connectivity:

```python
import time
import json
from pathlib import Path


def _verify_license(self, key: str) -> bool:
    """Verify license with grace period for offline scenarios."""
    cache_file = Path.home() / '.my_plugin_license_cache'

    # Try online validation first
    if self._online_validation(key):
        # Cache successful validation
        cache_file.write_text(json.dumps({
            'validated_at': time.time(),
            'key_hash': hashlib.sha256(key.encode()).hexdigest()
        }))
        return True

    # Fall back to cached validation (24-hour grace period)
    if cache_file.exists():
        cache = json.loads(cache_file.read_text())
        age = time.time() - cache['validated_at']
        if age < 86400:  # 24 hours
            return True

    return False
```

#### 5. Grace‑Perioden & Testversionen

Allow reasonable trial periods or grace windows:

```python
def _verify_license(self, key: str) -> bool:
    """Allow 14-day trial period."""
    if key.startswith('TRIAL-'):
        # Extract trial start date from key
        trial_start = self._parse_trial_date(key)
        days_elapsed = (datetime.now() - trial_start).days

        if days_elapsed <= 14:
            print(f"Trial mode: {14 - days_elapsed} days remaining")
            return True
        else:
            raise LicenseError(
                "Trial period expired. Purchase a license at https://myplugin.com"
            )

    return self._verify_paid_license(key)
```

### So listen Sie Ihr Plugin auf

Um Ihr Plugin auf der offiziellen Plugins‑Seite aufzulisten:

1. **Publish to PyPI** mit dem `otai-`‑Präfix (z. B. `otai-my-plugin`)
2. **Create documentation** describing features, installation, and configuration
3. **Submit a PR** to the Open Ticket AI documentation repository with:
   - Plugin name and description
   - Installation instructions
   - Pricing model (free, commercial, freemium)
   - Link to documentation
   - Support contact information
4. **Specify licensing** clearly in your plugin's README and PyPI metadata

### Beispiel: Vollständige kommerzielle Plugin‑Struktur

```
otai-my-commercial-plugin/
├── pyproject.toml              # Project metadata & dependencies
├── LICENSE                     # Your chosen license (proprietary, etc.)
├── README.md                   # Installation & purchase info
├── src/
│   └── otai_my_commercial_plugin/
│       ├── __init__.py
│       ├── plugin_factory.py   # Plugin with license validation
│       ├── licensing.py        # License validation logic
│       ├── pipes/
│       │   └── my_pipe.py
│       └── services/
│           └── my_service.py
├── tests/
│   └── unit/
│       ├── test_licensing.py   # Test license validation
│       └── test_plugin.py
└── docs/
    ├── installation.md         # How to install & license
    ├── configuration.md        # How to configure
    └── pricing.md             # Pricing & licensing options
```

### Support & Wartung

Als kommerzieller Plugin‑Entwickler sollten Sie Folgendes berücksichtigen:

- **Documentation**: Comprehensive guides for installation, configuration, troubleshooting
- **Support Channels**: Email, issue tracker, Discord/Slack community
- **Updates**: Regular releases for bug fixes and new features
- **Compatibility**: Test against new Open Ticket AI versions
- **Migration Guides**: Help users upgrade between versions

### Rechtliche Überlegungen

- **License Agreement**: Provide clear terms of use
- **Privacy Policy**: If collecting any data (license validation calls, analytics)
- **Compliance**: Ensure your plugin complies with relevant regulations (GDPR, etc.)
- **Intellectual Property**: Protect your code and trademarks appropriately

## Weitere Ressourcen

- [Plugin System](../plugins/plugin_system.md)
- [Dependency Injection](dependency_injection.md)
- [Services](services.md)
- [Pipeline Architecture](../users/pipeline-architecture.md)
- [Hugging Face Local plugin example](../plugins/hf_local.md)